name: Cloud Deployment Example Test

on:
  # Handle all branches for now
  push:
  pull_request:
  workflow_dispatch:

jobs:
  cloud-deployment-test:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'maven'

      - name: Setup Minikube
        uses: medyagh/setup-minikube@latest
        with:
          cpus: 4
          memory: 8192
          kubernetes-version: 'v1.28.0'
          driver: docker
          start-args: '--wait=all'

      - name: Verify Minikube
        run: |
          minikube status
          kubectl get nodes
          kubectl version --client

      - name: Install Strimzi Operator
        run: |
          kubectl create namespace kafka
          kubectl create -f 'https://strimzi.io/install/latest?namespace=kafka' -n kafka

          echo "Waiting for Strimzi operator deployment to be created..."
          for i in {1..30}; do
            if kubectl get deployment strimzi-cluster-operator -n kafka > /dev/null 2>&1; then
              echo "Deployment found"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "ERROR: Deployment not found after 30 seconds"
              exit 1
            fi
            sleep 1
          done

          echo "Waiting for Strimzi operator pod to be ready..."
          kubectl wait --for=condition=Available deployment/strimzi-cluster-operator -n kafka --timeout=300s
          kubectl wait --for=condition=Ready pod -l name=strimzi-cluster-operator -n kafka --timeout=300s
          echo "Strimzi operator ready"

      - name: Build Project
        run: |
          mvn clean install -DskipTests -B -V
          echo "Project built successfully"

      - name: Build Docker Image
        run: |
          eval $(minikube docker-env)
          cd examples/cloud-deployment/server
          mvn clean package -DskipTests -B
          docker build -t a2a-cloud-deployment:latest .
          echo "Docker image built"

          # Verify image exists
          docker images | grep a2a-cloud-deployment

      - name: Create Namespace
        run: |
          kubectl apply -f examples/cloud-deployment/k8s/00-namespace.yaml
          kubectl get namespace a2a-demo

      - name: Deploy PostgreSQL
        run: |
          kubectl apply -f examples/cloud-deployment/k8s/01-postgres.yaml
          echo "Waiting for PostgreSQL to be ready..."
          kubectl wait --for=condition=Ready pod -l app=postgres -n a2a-demo --timeout=180s
          kubectl get pods -n a2a-demo -l app=postgres

      - name: Deploy Kafka
        run: |
          kubectl apply -f examples/cloud-deployment/k8s/02-kafka.yaml
          echo "Waiting for Kafka to be ready (this may take several minutes)..."
          kubectl wait --for=condition=Ready kafka/a2a-kafka -n a2a-demo --timeout=600s
          kubectl get kafka -n a2a-demo

      - name: Deploy Agent ConfigMap
        run: |
          kubectl apply -f examples/cloud-deployment/k8s/03-agent-configmap.yaml
          kubectl get configmap -n a2a-demo

      - name: Deploy A2A Agent
        run: |
          kubectl apply -f examples/cloud-deployment/k8s/04-agent-deployment.yaml
          echo "Waiting for Agent pods to be ready..."
          kubectl wait --for=condition=Ready pod -l app=a2a-agent -n a2a-demo --timeout=180s

          echo "Verifying both pods are running..."
          READY_PODS=$(kubectl get pods -n a2a-demo -l app=a2a-agent -o jsonpath='{range .items[*]}{.status.conditions[?(@.type=="Ready")].status}{"\n"}{end}' | grep -c "True")
          if [ "$READY_PODS" -lt 2 ]; then
            echo "ERROR: Expected 2 ready pods, got $READY_PODS"
            kubectl get pods -n a2a-demo -l app=a2a-agent
            kubectl describe pods -n a2a-demo -l app=a2a-agent
            exit 1
          fi

          kubectl get pods -n a2a-demo -l app=a2a-agent -o wide

      - name: Verify Deployment
        run: |
          cd examples/cloud-deployment/scripts
          ./verify.sh

      - name: Setup Port Forward
        run: |
          kubectl port-forward -n a2a-demo svc/a2a-agent-service 8080:8080 &
          PF_PID=$!
          echo "PF_PID=$PF_PID" >> $GITHUB_ENV

          # Wait for port-forward to be ready
          echo "Waiting for port-forward to be ready..."
          for i in {1..30}; do
            if curl -s http://localhost:8080/health/ready > /dev/null 2>&1; then
              echo "Port-forward is ready"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "ERROR: Port-forward failed to become ready"
              exit 1
            fi
            sleep 2
          done

      - name: Test Agent Endpoint
        run: |
          echo "Testing agent card endpoint..."
          curl -f http://localhost:8080/a2a/agent-card | jq .

          echo "Testing health endpoints..."
          curl -f http://localhost:8080/health/live
          curl -f http://localhost:8080/health/ready

      - name: Run Integration Test
        run: |
          cd examples/cloud-deployment/server
          timeout 120 mvn test-compile exec:java -Dexec.mainClass="io.a2a.examples.cloud.A2ACloudExampleClient" -Dagent.url=http://localhost:8080
        env:
          MAVEN_OPTS: "-Xmx1024m"

      - name: Collect Logs
        if: always()
        run: |
          mkdir -p logs

          echo "=== Collecting Agent Pod Logs ==="
          kubectl logs -n a2a-demo -l app=a2a-agent --all-containers --tail=500 > logs/agent-pods.log 2>&1 || echo "Failed to collect agent logs"

          echo "=== Collecting PostgreSQL Logs ==="
          kubectl logs -n a2a-demo -l app=postgres --tail=200 > logs/postgres.log 2>&1 || echo "Failed to collect postgres logs"

          echo "=== Collecting Kafka Logs ==="
          kubectl logs -n a2a-demo -l strimzi.io/cluster=a2a-kafka --tail=200 > logs/kafka.log 2>&1 || echo "Failed to collect kafka logs"

          echo "=== Collecting Strimzi Operator Logs ==="
          kubectl logs -n kafka -l name=strimzi-cluster-operator --tail=200 > logs/strimzi-operator.log 2>&1 || echo "Failed to collect strimzi logs"

          echo "=== Collecting Pod Status ==="
          kubectl get pods -n a2a-demo -o wide > logs/pod-status.txt 2>&1 || echo "Failed to collect pod status"
          kubectl describe pods -n a2a-demo > logs/pod-describe.txt 2>&1 || echo "Failed to describe pods"

          echo "=== Collecting Events ==="
          kubectl get events -n a2a-demo --sort-by='.lastTimestamp' > logs/events.txt 2>&1 || echo "Failed to collect events"

          echo "=== Collecting Minikube Status ==="
          minikube status > logs/minikube-status.txt 2>&1 || echo "Failed to collect minikube status"

          echo "Logs collected successfully"
          ls -lah logs/

      - name: Upload Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cloud-deployment-logs
          path: logs/
          retention-days: 5

      - name: Cleanup
        if: always()
        run: |
          # Kill port-forward if still running
          if [ -n "$PF_PID" ]; then
            kill $PF_PID || true
          fi

          # Delete resources
          kubectl delete namespace a2a-demo --ignore-not-found=true --timeout=60s || true
          kubectl delete namespace kafka --ignore-not-found=true --timeout=60s || true
